"use strict";(self.webpackChunkfusion_labs=self.webpackChunkfusion_labs||[]).push([[338,454],{81(E,_,t){t.d(_,{n:()=>s});class s{getEraseSize(E,_){return _}}},338(E,_,t){t.d(_,{ESP32ROM:()=>S});var s=t(81);class S extends s.n{constructor(){super(...arguments),this.CHIP_NAME="ESP32",this.IMAGE_CHIP_ID=0,this.EFUSE_RD_REG_BASE=1073061888,this.DR_REG_SYSCON_BASE=1073111040,this.UART_CLKDIV_REG=1072955412,this.UART_CLKDIV_MASK=1048575,this.UART_DATE_REG_ADDR=1610612856,this.XTAL_CLK_DIVIDER=1,this.FLASH_SIZES={"1MB":0,"2MB":16,"4MB":32,"8MB":48,"16MB":64},this.FLASH_WRITE_SIZE=1024,this.BOOTLOADER_FLASH_OFFSET=4096,this.SPI_REG_BASE=1072963584,this.SPI_USR_OFFS=28,this.SPI_USR1_OFFS=32,this.SPI_USR2_OFFS=36,this.SPI_W0_OFFS=128,this.SPI_MOSI_DLEN_OFFS=40,this.SPI_MISO_DLEN_OFFS=44}async readEfuse(E,_){const t=this.EFUSE_RD_REG_BASE+4*_;return E.debug("Read efuse "+t),await E.readReg(t)}async getPkgVersion(E){const _=await this.readEfuse(E,3);let t=_>>9&7;return t+=(_>>2&1)<<3,t}async getChipRevision(E){const _=await this.readEfuse(E,3),t=await this.readEfuse(E,5),s=await E.readReg(this.DR_REG_SYSCON_BASE+124);return 0!=(_>>15&1)?0!=(t>>20&1)?0!=(s>>31&1)?3:2:1:0}async getChipDescription(E){const _=["ESP32-D0WDQ6","ESP32-D0WD","ESP32-D2WD","","ESP32-U4WDH","ESP32-PICO-D4","ESP32-PICO-V3-02"];let t="";const s=await this.getPkgVersion(E),S=await this.getChipRevision(E),i=3==S;return 0!=(1&await this.readEfuse(E,3))&&(_[0]="ESP32-S0WDQ6",_[1]="ESP32-S0WD"),i&&(_[5]="ESP32-PICO-V3"),t=s>=0&&s<=6?_[s]:"Unknown ESP32",!i||0!==s&&1!==s||(t+="-V3"),t+" (revision "+S+")"}async getChipFeatures(E){const _=["Wi-Fi"],t=await this.readEfuse(E,3);0===(2&t)&&_.push(" BT");0!==(1&t)?_.push(" Single Core"):_.push(" Dual Core");if(0!==(8192&t)){0!==(4096&t)?_.push(" 160MHz"):_.push(" 240MHz")}const s=await this.getPkgVersion(E);-1!==[2,4,5,6].indexOf(s)&&_.push(" Embedded Flash"),6===s&&_.push(" Embedded PSRAM");0!==(await this.readEfuse(E,4)>>8&31)&&_.push(" VRef calibration in efuse");0!==(t>>14&1)&&_.push(" BLK3 partially reserved");const S=3&await this.readEfuse(E,6);return _.push(" Coding Scheme "+["None","3/4","Repeat (UNSUPPORTED)","Invalid"][S]),_}async getCrystalFreq(E){const _=await E.readReg(this.UART_CLKDIV_REG)&this.UART_CLKDIV_MASK,t=E.transport.baudrate*_/1e6/this.XTAL_CLK_DIVIDER;let s;return s=t>33?40:26,Math.abs(s-t)>1&&E.info("WARNING: Unsupported crystal in use"),s}_d2h(E){const _=(+E).toString(16);return 1===_.length?"0"+_:_}async readMac(E){let _=await this.readEfuse(E,1);_>>>=0;let t=await this.readEfuse(E,2);t>>>=0;const s=new Uint8Array(6);return s[0]=t>>8&255,s[1]=255&t,s[2]=_>>24&255,s[3]=_>>16&255,s[4]=_>>8&255,s[5]=255&_,this._d2h(s[0])+":"+this._d2h(s[1])+":"+this._d2h(s[2])+":"+this._d2h(s[3])+":"+this._d2h(s[4])+":"+this._d2h(s[5])}}},454(E,_,t){t.d(_,{ESP32P4ROM:()=>S});var s=t(338);class S extends s.ESP32ROM{constructor(){super(...arguments),this.CHIP_NAME="ESP32-P4",this.IMAGE_CHIP_ID=18,this.IROM_MAP_START=1073741824,this.IROM_MAP_END=1275068416,this.DROM_MAP_START=1073741824,this.DROM_MAP_END=1275068416,this.BOOTLOADER_FLASH_OFFSET=8192,this.CHIP_DETECT_MAGIC_VALUE=[0,182303440],this.UART_DATE_REG_ADDR=1343004812,this.EFUSE_BASE=1343410176,this.EFUSE_BLOCK1_ADDR=this.EFUSE_BASE+68,this.MAC_EFUSE_REG=this.EFUSE_BASE+68,this.SPI_REG_BASE=1342754816,this.SPI_USR_OFFS=24,this.SPI_USR1_OFFS=28,this.SPI_USR2_OFFS=32,this.SPI_MOSI_DLEN_OFFS=36,this.SPI_MISO_DLEN_OFFS=40,this.SPI_W0_OFFS=88,this.EFUSE_RD_REG_BASE=this.EFUSE_BASE+48,this.EFUSE_PURPOSE_KEY0_REG=this.EFUSE_BASE+52,this.EFUSE_PURPOSE_KEY0_SHIFT=24,this.EFUSE_PURPOSE_KEY1_REG=this.EFUSE_BASE+52,this.EFUSE_PURPOSE_KEY1_SHIFT=28,this.EFUSE_PURPOSE_KEY2_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY2_SHIFT=0,this.EFUSE_PURPOSE_KEY3_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY3_SHIFT=4,this.EFUSE_PURPOSE_KEY4_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY4_SHIFT=8,this.EFUSE_PURPOSE_KEY5_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY5_SHIFT=12,this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG=this.EFUSE_RD_REG_BASE,this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT=1<<20,this.EFUSE_SPI_BOOT_CRYPT_CNT_REG=this.EFUSE_BASE+52,this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK=7<<18,this.EFUSE_SECURE_BOOT_EN_REG=this.EFUSE_BASE+56,this.EFUSE_SECURE_BOOT_EN_MASK=1<<20,this.PURPOSE_VAL_XTS_AES256_KEY_1=2,this.PURPOSE_VAL_XTS_AES256_KEY_2=3,this.PURPOSE_VAL_XTS_AES128_KEY=4,this.SUPPORTS_ENCRYPTED_FLASH=!0,this.FLASH_ENCRYPTED_WRITE_ALIGN=16,this.MEMORY_MAP=[[0,65536,"PADDING"],[1073741824,1275068416,"DROM"],[1341128704,1341784064,"DRAM"],[1341128704,1341784064,"BYTE_ACCESSIBLE"],[1337982976,1338114048,"DROM_MASK"],[1337982976,1338114048,"IROM_MASK"],[1073741824,1275068416,"IROM"],[1341128704,1341784064,"IRAM"],[1343258624,1343291392,"RTC_IRAM"],[1343258624,1343291392,"RTC_DRAM"],[1611653120,1611661312,"MEM_INTERNAL2"]],this.UF2_FAMILY_ID=1026592404,this.EFUSE_MAX_KEY=5,this.KEY_PURPOSES={0:"USER/EMPTY",1:"ECDSA_KEY",2:"XTS_AES_256_KEY_1",3:"XTS_AES_256_KEY_2",4:"XTS_AES_128_KEY",5:"HMAC_DOWN_ALL",6:"HMAC_DOWN_JTAG",7:"HMAC_DOWN_DIGITAL_SIGNATURE",8:"HMAC_UP",9:"SECURE_BOOT_DIGEST0",10:"SECURE_BOOT_DIGEST1",11:"SECURE_BOOT_DIGEST2",12:"KM_INIT_KEY"}}async getPkgVersion(E){const _=this.EFUSE_BLOCK1_ADDR+8;return await E.readReg(_)>>27&7}async getMinorChipVersion(E){const _=this.EFUSE_BLOCK1_ADDR+8;return 15&await E.readReg(_)}async getMajorChipVersion(E){const _=this.EFUSE_BLOCK1_ADDR+8;return await E.readReg(_)>>4&3}async getChipDescription(E){const _=0===await this.getPkgVersion(E)?"ESP32-P4":"unknown ESP32-P4",t=await this.getMajorChipVersion(E),s=await this.getMinorChipVersion(E);return"".concat(_," (revision v").concat(t,".").concat(s,")")}async getChipFeatures(E){return["High-Performance MCU"]}async getCrystalFreq(E){return 40}async getFlashVoltage(E){}async overrideVddsdio(E){E.debug("VDD_SDIO overrides are not supported for ESP32-P4")}async readMac(E){let _=await E.readReg(this.MAC_EFUSE_REG);_>>>=0;let t=await E.readReg(this.MAC_EFUSE_REG+4);t=t>>>0&65535;const s=new Uint8Array(6);return s[0]=t>>8&255,s[1]=255&t,s[2]=_>>24&255,s[3]=_>>16&255,s[4]=_>>8&255,s[5]=255&_,this._d2h(s[0])+":"+this._d2h(s[1])+":"+this._d2h(s[2])+":"+this._d2h(s[3])+":"+this._d2h(s[4])+":"+this._d2h(s[5])}async getFlashCryptConfig(E){}async getSecureBootEnabled(E){return await E.readReg(this.EFUSE_SECURE_BOOT_EN_REG)&this.EFUSE_SECURE_BOOT_EN_MASK}async getKeyBlockPurpose(E,_){if(_<0||_>this.EFUSE_MAX_KEY)return void E.debug("Valid key block numbers must be in range 0-".concat(this.EFUSE_MAX_KEY));const t=[[this.EFUSE_PURPOSE_KEY0_REG,this.EFUSE_PURPOSE_KEY0_SHIFT],[this.EFUSE_PURPOSE_KEY1_REG,this.EFUSE_PURPOSE_KEY1_SHIFT],[this.EFUSE_PURPOSE_KEY2_REG,this.EFUSE_PURPOSE_KEY2_SHIFT],[this.EFUSE_PURPOSE_KEY3_REG,this.EFUSE_PURPOSE_KEY3_SHIFT],[this.EFUSE_PURPOSE_KEY4_REG,this.EFUSE_PURPOSE_KEY4_SHIFT],[this.EFUSE_PURPOSE_KEY5_REG,this.EFUSE_PURPOSE_KEY5_SHIFT]],[s,S]=t[_];return await E.readReg(s)>>S&15}async isFlashEncryptionKeyValid(E){const _=[];for(let S=0;S<=this.EFUSE_MAX_KEY;S++){const t=await this.getKeyBlockPurpose(E,S);_.push(t)}if(void 0!==typeof _.find(E=>E===this.PURPOSE_VAL_XTS_AES128_KEY))return!0;const t=_.find(E=>E===this.PURPOSE_VAL_XTS_AES256_KEY_1),s=_.find(E=>E===this.PURPOSE_VAL_XTS_AES256_KEY_2);return void 0!==typeof t&&void 0!==typeof s}}}}]);
//# sourceMappingURL=454.fff10b25.chunk.js.map